---
outline: deep
date: 2024-03-21
---

# 2024-03-21 面试题

1. commonJS, AMD, CMD, ESModule 区别详细总结
2. Post 为什么会发送两次请求

## 问题 1

我之前写过一篇文章是关于前端工程中的模块化的，[点击直达](/articles/engineering/module.md)

这里就详细总结一下:

1. AMD/CMD/CommonJS 是 js 模块化开发的规范，对应的实现是 require.js/sea.js/node.js。
2. CommonJS 主要主要针对服务端，AMD/CMD/ESModule 主要针对浏览器端，容易混淆的是 AMD/CMD。（针对服务器端和浏览器端有什么本质的区别？服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等它加载完再执行。而浏览器端要保存效率，需要采用异步加载，这就需要一个预处理，提前将所需要的模块文件并行加载好）。
3. AMD/CMD 区别，虽然都是并行加载 js 文件，但还是有所区别，AMD 是预加载，在并行加载 js 文件的同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而 CMD 是懒加载，虽然会一开始就并行加载 js 文件，但是不会执行，而是在需要的时候才执行。
4. AMD/CMD 的优缺点：一个的优点就是另一个的缺点：

- AMD 优点：加载快速，尤其遇到多个大文件，因为并行解析，所以同一时间可以解析多个文件。
- AMD 缺点：并行加载，异步处理，加载顺序不一定，可能会造成一些困扰，甚至为程序埋下大坑。
- CMD 优点：因为只有在使用的时候才会解析执行 js 文件，因此，每个 js 文件的执行顺序在代码中是有体现的，是可控的。
- CMD 缺点：执行等待时间会叠加。因为每个文件执行时是同步执行(串行执行)，因此事件是所有文件解析执行时间之和，尤其在文件较多较大时，这种缺点尤为明显。（确切的来说，JS 时单线程，所有 JS 文件执行时间叠加在 AMD 和 CMD 中是一样的。但是 CMD 是使用时执行，没法利用空闲时间，而是 AMD 是文件加载好就执行，往往可以利用一些贡献时间。这么来看，CMD 比 AMD 的优点还是很明显的，毕竟 AMD 加载好的时候也未必就是 JS 引擎的空闲时间）

5. CommonJS 和 ESModule 区别：CommonJS 模块输出的是一个值的拷贝，ESModule 输出的是值的引用
6. 如何使用？CommonJS 的话，因为 NodeJS 就是它的实现，所以使用 node 就行，也不用引入其他包。AMD 则是通过`script`标签引入 require,js，CMD 则是引入 sea.js

## 问题 2

首先要清楚`options请求`，它是用于请求获取有 Request—URI 标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以采取具体资源请求前，决定对该资源采取何种必要措施，或者了解服务器的性能。通俗来讲就是在发起正式请求前，先进行一次预检请求。看服务器端返回一些信息，浏览器拿到后看后台是否允许进行访问。

如何产生预检请求：

1. **复杂请求**。复杂请求对应的就是简单请求。简单请求的定义是请求方法是`GET`, `HEAD`或`POST`，并且当请求方法是`POST`时，Content-Type 必须是`application/x-www-form-urlencoded`,` multipart/form-data`或`text/plain`中的一个值；请求中没有自定义 http 头部。自定义头部就是通常会遇到在 header 中加上一些 token 或其他用户信息来做校验。
2. **跨域**。头部自定义信息的请求方式成为带预检(preflighted)的跨域请求。

::: tip

- 在实际调用接口之前，会先发一个预检请求，检测服务器端是否支持真实的请求进行跨域的请求。
- 真实请求在预检请求中，通过请求头将`Access-Control-Request-Headers`和`Access-Control-Request-Method`发送给后台，另外浏览器会自行加上一个 Origin 请求地址。服务器端在接收到预检请求后，根据资源权限配置，在响应头加入`Access-Control-Allow-Headers(允许跨域请求的请求头)`, `Access-Control=Allwo-Methods(允许跨域请求的请求方式)`, `Access-Control-Allow-Origin(允许跨域请求的域)`。
- 服务器端还可以通过`Access-Control-Max-Age`来设置一定时间内无需再进行预检请求，直接用之前的预检请求的协商结果。浏览器再根据服务器端返回的信息，进行决定是否进行真实的跨域请求。这个过程对应用户来说也是透明的。
- 在响应头中凡是浏览器请求中携带了身份信息，而响应头中没有返回`Access-Control-Allow-Credentials: true`的，浏览器都会忽略此次响应。
  :::

如何避免：

1. 使用代理，避开跨域(使用相同域名和端口)
2. 使用简单请求
3. 配置服务器允许特定的自定义请求头部或者
4. 不使用携带自定义配置的头部信息

## 参考

[前端模块化——彻底搞懂 AMD、CMD、ESM 和 CommonJS](https://www.cnblogs.com/chenwenhao/p/12153332.html)

[前端涨薪功法：CORS 策略中 post 为什么会发送两次请求？](https://juejin.cn/post/7270899875022028837)

[http 中的 post 请求发⽣了两次（多了⼀次 options 请求）的原因](https://blog.csdn.net/weixin_40016215/article/details/125199946)
